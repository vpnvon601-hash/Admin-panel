<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LA ZONA DEL BARBERO ‚Äî Admin Panel</title>
  <style>
    :root{
      --bg:#06070a; --card:#0e1115; --muted:#9aa0a6; --line:#1e252b;
      --text:#e6eef3; 
      --accent:#d0d7de; 
      --accent-2:#aeb5bc; 
      --glass:rgba(255,255,255,0.03);
      --danger:#ef6b6b;
      --good:#21b563; /* Verde para citas finalizadas */
      --radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background-color:#000000;color:var(--text);-webkit-font-smoothing:antialiased}
    
    /* Watermark - Copiado de agenda.html */
    body::before {
      content: ''; position: fixed; inset: 0;
      background-image: url('20251206_091028.png'); 
      background-repeat: no-repeat; background-position: center center;
      background-size: 400px; opacity: 0.10; pointer-events: none; z-index: -1;
    }

    .wrap{max-width:1100px;margin:36px auto;padding:22px}
    @media(max-width:980px){.wrap{padding:16px}}
    
    .brand{display:flex;align-items:center;gap:12px;justify-content:center;font-weight:800;font-size:20px;margin-bottom:22px}
    .brand .logo{ height: 50px; width: 100px; border-radius: 0; background: transparent; display: inline-block; font-weight: normal; color: transparent; background-image: url('20251211_104822.png'); background-size: contain; background-repeat: no-repeat; background-position: left center; margin-right: 12px; }

    .card{background:linear-gradient(180deg, rgba(255,255,255,0.05), transparent);padding:18px;border-radius:var(--radius);border:1px solid var(--line);box-shadow:0 6px 30px rgba(0,0,0,0.6);margin-bottom:22px}
    h3,h4{margin:0 0 12px 0;font-weight:700}
    .small{font-size:13px;color:var(--muted)}

    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    input,select{width:100%;padding:12px;border:1px solid var(--line);border-radius:10px;background:transparent;color:var(--text);font-size:15px;margin-bottom:12px}
    input::placeholder{color:#6f7880}
    input:focus,select:focus{outline:none;box-shadow:0 4px 18px rgba(208,215,222,0.12);border-color:rgba(208,215,222,0.2)}

    .row{display:flex;gap:10px;margin-bottom:12px}
    button.primary{background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#071018;border:none;padding:12px 14px;border-radius:10px;cursor:pointer;font-weight:800;box-shadow:0 8px 20px rgba(208,215,222,0.06)}
    button{background:transparent;color:var(--text);border:1px solid var(--line);padding:10px 12px;border-radius:10px;cursor:pointer}
    button:disabled{opacity:0.5;cursor:not-allowed}
    .loader{display:inline-block;width:14px;height:14px;border-radius:50%;border:2px solid var(--line);border-top-color:var(--accent);animation:spin .9s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* Estilos espec√≠ficos del admin */
    #login-screen{display:grid;place-items:center;min-height:80vh}
    #admin-panel{display:none}
    
    .appointment-list{display:grid;gap:14px}
    .appointment-item{
        padding:16px; border-radius:var(--radius); border:1px solid var(--line);
        background:rgba(255,255,255,0.02); display:grid; grid-template-columns:1fr 1fr; gap:8px;
        position:relative;
    }
    @media(max-width:680px){.appointment-item{grid-template-columns:1fr}}

    .appointment-item.completed{border-color:var(--good); opacity:0.7}
    .appointment-item.completed:before{content:'‚úÖ FINALIZADA'; position:absolute; top:-10px; right:10px; background:var(--good); color:#000; padding:4px 8px; border-radius:6px; font-size:11px; font-weight:700}
    
    .appointment-item.absence{border-color:var(--danger); opacity:0.8; background:rgba(239,107,107,0.04)}
    .appointment-item.absence:before{content:'‚ùå AUSENCIA'; position:absolute; top:-10px; right:10px; background:var(--danger); color:#000; padding:4px 8px; border-radius:6px; font-size:11px; font-weight:700}

    .info-block div{margin-bottom:4px; font-size:14px}
    .info-block strong{color:var(--accent)}
    .actions{display:flex; gap:8px; justify-content:flex-end; align-items:flex-end;}
    
    .filter-bar{display:grid; grid-template-columns:1fr 1fr 1fr 100px; gap:10px; margin-bottom:18px}
    @media(max-width:680px){.filter-bar{grid-template-columns:1fr;}}
    
    /* Estilos para el modal de edici√≥n/ausencia */
    .modal-overlay{position:fixed; inset:0; background:rgba(0,0,0,0.8); backdrop-filter:blur(4px); z-index:1000; display:none; place-items:center}
    .modal-content{background:var(--card); padding:22px; border-radius:var(--radius); border:1px solid var(--line); max-width:400px; width:90%; box-shadow:0 12px 30px rgba(0,0,0,0.7)}
    .modal-content h4{margin-bottom:16px}
    .modal-content button{width:48%}
    .modal-content .row button{width:100%}
  </style>
</head>
<body>

<div class="wrap">
  <div class="brand"><span class="logo">LB</span> LA ZONA DEL BARBERO ‚Äî <span class="small" style="margin-left:8px">Panel Admin</span></div>

  <div id="login-screen">
    <div class="card" style="width:340px">
      <h4>üë§ Iniciar Sesi√≥n</h4>
      <p class="small">Solo personal autorizado.</p>
      <label for="username">Usuario (Barbero)</label>
      <select id="username">
        <option value="">Seleccionar barbero...</option>
      </select>
      <label for="password">Contrase√±a</label>
      <input id="password" type="password" placeholder="Contrase√±a">
      <button class="primary" id="btnLogin">Acceder</button>
      <div id="login-status" class="small" style="margin-top:10px;color:var(--danger)"></div>
    </div>
  </div>

  <div id="admin-panel">
    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px">
        <h3>Bienvenido, <span id="barber-name-display"></span></h3>
        <button id="btnLogout">Cerrar Sesi√≥n</button>
      </div>

      <div class="card" style="padding:16px">
        <h4 style="margin-bottom:16px">üóì Mis Citas y Agenda</h4>
        
        <div class="filter-bar">
          <div><label>Buscar por Nombre de Cliente</label><input id="search-name" type="text" placeholder="Nombre completo o parte..." style="margin-bottom:0"></div>
          <div><label>Seleccionar Fecha</label><input id="search-date" type="date" style="margin-bottom:0"></div>
          <div><label>Estado</label>
              <select id="filter-status" style="margin-bottom:0">
                  <option value="all">Todas</option>
                  <option value="pending">Pendientes</option>
                  <option value="completed">Finalizadas</option>
              </select>
          </div>
          <div><label style="opacity:0">Aplicar</label><button class="primary" id="btnSearch" style="padding:12px; margin-bottom:0">Buscar</button></div>
        </div>
        
        <div id="appointment-status" class="small" style="margin-bottom:12px; font-weight:700">Cargando citas...</div>
        <div id="appointment-list" class="appointment-list">
          </div>
      </div>

      <div class="card">
        <h4>üö´ Gesti√≥n de Ausencias</h4>
        <p class="small">Bloquea horas o d√≠as completos en tu agenda.</p>
        
        <label>Tipo de Ausencia</label>
        <select id="absence-type">
          <option value="day">D√≠a Completo</option>
          <option value="interval">Intervalo de Horas</option>
        </select>

        <div id="absence-day-controls">
          <label>Fecha de Ausencia</label>
          <input id="absence-date" type="date">
        </div>
        
        <div id="absence-interval-controls" style="display:none">
          <label>Fecha del Intervalo</label>
          <input id="interval-date" type="date">
          <div class="row">
            <div style="flex:1"><label>Hora Inicio (ej: 13:00)</label><input id="interval-start" type="time"></div>
            <div style="flex:1"><label>Hora Fin (ej: 15:00)</label><input id="interval-end" type="time"></div>
          </div>
        </div>

        <label>Motivo</label>
        <input id="absence-reason" type="text" placeholder="Ej: Cita m√©dica, Almuerzo, D√≠a libre">

        <button class="primary" id="btnAddAbsence">Bloquear Agenda</button>
        <div id="absence-list-status" class="small" style="margin-top:10px; color:var(--danger)"></div>
        <div id="absence-list" style="margin-top:10px">
            </div>
      </div>

    </div>
  </div>
</div>


<div id="edit-modal" class="modal-overlay">
  <div class="modal-content">
    <h4>‚úèÔ∏è Editar Cita</h4>
    <p class="small">Solo edita la hora/servicio si has confirmado la disponibilidad con el cliente.</p>
    
    <input type="hidden" id="edit-original-date">
    <input type="hidden" id="edit-barbero">
    <input type="hidden" id="edit-appointment-key">

    <label>Cliente</label>
    <input id="edit-nombre" type="text" placeholder="Nombre completo">
    
    <label>Tel√©fono</label>
    <input id="edit-telefono" type="tel" placeholder="+57 3XX XXX XXXX">
    
    <label>Servicio</label>
    <select id="edit-servicio">
      <option value="">Seleccionar...</option>
      <option value="Corte" data-duration="60">Corte de cabello ‚Äî 1 h</option>
      <option value="Corte + ceja" data-duration="60">Corte + ceja ‚Äî 1 h</option>
      <option value="Corte + barba + ceja" data-duration="60">Corte + barba + ceja ‚Äî 1 h</option>
      <option value="Corte + barba" data-duration="60">Corte + barba ‚Äî 1 h</option>
      <option value="Mascarilla" data-duration="120">Mascarilla ‚Äî 2 h</option>
      <option value="Tinte global completo" data-duration="240">Tinte global completo ‚Äî 4 h</option>
      <option value="Tinte mechas global" data-duration="240">Tinte mechas global ‚Äî 4 h</option>
      <option value="Corte VIP" data-duration="150">Corte + Limpieza Facial (VIP) ‚Äî 2 h 30 min</option>
    </select>
    
    <label>Fecha</label>
    <input id="edit-fecha" type="date">

    <label>Hora Inicio</label>
    <input id="edit-hora" type="time">

    <div class="row">
      <button id="btnSaveEdit" class="primary">Guardar Cambios</button>
      <button id="btnCloseEdit">Cancelar</button>
    </div>
  </div>
</div>


<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import { getDatabase, ref, get, child, remove, update, runTransaction, push, query, orderByChild, startAt, endAt } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js";

    // 1. CONFIGURACI√ìN
    const firebaseConfig = {
      apiKey: "AIzaSyAN8piM_UR3kLDUnJFYe5diazItfvYIlSA",
      authDomain: "lazonadelbarbero-b4e75.firebaseapp.com",
      databaseURL: "https://lazonadelbarbero-b4e75-default-rtdb.firebaseio.com",
      projectId: "lazonadelbarbero-b4e75",
      storageBucket: "lazonadelbarbero-b4e75.firebasestorage.app",
      messagingSenderId: "251180096928",
      appId: "1:251180096928:web:86d0ab83c7e444af79d8c5",
      measurementId: "G-G4YL7M4Z00"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const OPEN_MIN = 7 * 60; // 7:00 AM
    const CLOSE_MIN = 22 * 60; // 10:00 PM (22:00)
    
    // ** LISTA DE BARBEROS Y SUS CONTRASE√ëAS (Debe ser REAL y SECRETA) **
    // ESTO ES TEMPORAL y MUY INSEGURO. Idealmente, se debe usar Firebase Authentication.
    const BARBERS_AUTH = {
      "Dilan": "dilan123", // Reemplazar
      "Alejandro": "alejo123", // Reemplazar
      "Leonardo": "leo123", // Reemplazar
      "Santiago": "santi123" // Reemplazar
    };
    const BARBERS_NAMES = Object.keys(BARBERS_AUTH);
    
    // Almacenamiento de estado
    let loggedInBarber = null;
    const allAppointments = []; // Para almacenar todas las citas cargadas para el filtrado
    
    // Utilidades
    function timeToMinutes(timeStr){
      const [h, m] = timeStr.split(':').map(Number);
      return h * 60 + m;
    }
    function minutesToTime(m){
      const h = Math.floor(m/60);
      const mm = m % 60;
      return `${String(h).padStart(2,'0')}:${String(mm).padStart(2,'0')}`;
    }
    function minutesToShortAmPm(m){
      const hh = Math.floor(m/60);
      const mm = m % 60;
      const isPM = hh >= 12;
      let h12 = hh % 12;
      if(h12 === 0) h12 = 12;
      const mmPart = mm === 0 ? '' : `:${String(mm).padStart(2,'0')}`;
      return `${h12}${mmPart}${isPM ? 'pm' : 'am'}`;
    }
    function getDuration(serviceValue){
        const opt = document.querySelector(`#edit-servicio option[value="${serviceValue}"]`);
        return Number(opt?.dataset.duration) || 60;
    }
    function getCurrentDateISO(){
        const t = new Date();
        const y = t.getFullYear(), m = String(t.getMonth() + 1).padStart(2, '0'), d = String(t.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
    }

    // 2. L√ìGICA DE AUTENTICACI√ìN
    const loginScreen = document.getElementById('login-screen');
    const adminPanel = document.getElementById('admin-panel');
    const usernameSelect = document.getElementById('username');
    const passwordInput = document.getElementById('password');
    const loginStatus = document.getElementById('login-status');
    const barberNameDisplay = document.getElementById('barber-name-display');

    // Llenar el select de barbero
    BARBERS_NAMES.forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      usernameSelect.appendChild(opt);
    });

    document.getElementById('btnLogin').addEventListener('click', () => {
      const user = usernameSelect.value;
      const pass = passwordInput.value;

      loginStatus.textContent = '';
      if(!user || !pass){ loginStatus.textContent = 'Ingresa usuario y contrase√±a.'; return; }

      if(BARBERS_AUTH[user] === pass){
        loggedInBarber = user;
        sessionStorage.setItem('loggedInBarber', user);
        barberNameDisplay.textContent = user;
        loginScreen.style.display = 'none';
        adminPanel.style.display = 'block';
        document.getElementById('search-date').value = getCurrentDateISO();
        loadAppointments();
        loadAbsences();
      } else {
        loginStatus.textContent = 'Credenciales incorrectas.';
      }
    });

    document.getElementById('btnLogout').addEventListener('click', () => {
      loggedInBarber = null;
      sessionStorage.removeItem('loggedInBarber');
      passwordInput.value = '';
      loginScreen.style.display = 'grid';
      adminPanel.style.display = 'none';
    });

    // Revisar si ya hay una sesi√≥n
    const savedBarber = sessionStorage.getItem('loggedInBarber');
    if(savedBarber && BARBERS_AUTH[savedBarber]){
      loggedInBarber = savedBarber;
      barberNameDisplay.textContent = savedBarber;
      loginScreen.style.display = 'none';
      adminPanel.style.display = 'block';
      document.getElementById('search-date').value = getCurrentDateISO();
      loadAppointments();
      loadAbsences();
    }


    // 3. L√ìGICA DE GESTI√ìN DE CITAS
    const appointmentListEl = document.getElementById('appointment-list');
    const appointmentStatusEl = document.getElementById('appointment-status');
    const searchNameInput = document.getElementById('search-name');
    const searchDateInput = document.getElementById('search-date');
    const filterStatusSelect = document.getElementById('filter-status');
    document.getElementById('btnSearch').addEventListener('click', loadAppointments);

    async function fetchAppointments(barber, dateISO = null){
      appointmentStatusEl.textContent = 'Cargando...';
      try{
        let appointments = [];
        if(dateISO){
          // Cargar solo citas de una fecha espec√≠fica
          const path = `appointments/${barber}/${dateISO}`;
          const snap = await get(child(ref(db), path));
          if(snap.exists()){
            const val = snap.val();
            for(const key of Object.keys(val)){
              const a = val[key];
              a._id = key;
              a.date = dateISO; // Agregar la fecha ya que se perdi√≥ en la ruta
              appointments.push(a);
            }
          }
        } else {
            // Cargar citas de todos los d√≠as (para busqueda por nombre general)
            const path = `appointments/${barber}`;
            const snap = await get(child(ref(db), path));
            if(snap.exists()){
                const dates = snap.val();
                for(const date of Object.keys(dates)){
                    const dailyAppts = dates[date];
                    for(const key of Object.keys(dailyAppts)){
                        const a = dailyAppts[key];
                        a._id = key;
                        a.date = date; 
                        appointments.push(a);
                    }
                }
            }
        }
        
        // Convertir n√∫meros y ordenar
        appointments.forEach(a => {
            a.startMinutes = Number(a.startMinutes);
            a.endMinutes = Number(a.endMinutes || (a.startMinutes + Number(a.durationMinutes)));
            a.durationMinutes = Number(a.durationMinutes);
            a.completed = a.completed || false;
        });
        appointments.sort((a,b) => {
            // Priorizar citas por fecha y luego por hora de inicio
            if(a.date > b.date) return 1;
            if(a.date < b.date) return -1;
            return a.startMinutes - b.startMinutes;
        });
        
        allAppointments.length = 0; // Limpiar array global
        allAppointments.push(...appointments);
        return appointments;

      } catch(e){
        console.error("Error fetching appointments:", e);
        appointmentStatusEl.textContent = 'Error al cargar las citas.';
        return [];
      }
    }

    async function loadAppointments(){
      if(!loggedInBarber) return;
      
      const searchDate = searchDateInput.value;
      const searchName = searchNameInput.value.trim().toLowerCase();
      const filterStatus = filterStatusSelect.value;
      
      let appointments;
      if(searchDate && searchName){
        // Si hay fecha y nombre, buscar por fecha y luego filtrar por nombre localmente
        appointments = await fetchAppointments(loggedInBarber, searchDate);
      } else if (searchDate) {
        // Solo buscar por fecha
        appointments = await fetchAppointments(loggedInBarber, searchDate);
      } else if (searchName) {
        // Solo buscar por nombre. Debe cargar todas las citas del barbero (ineficiente, pero necesario si no hay √≠ndice)
        appointments = await fetchAppointments(loggedInBarber); 
      } else {
        // Sin filtros, mostrar solo las de hoy o la fecha del campo (por defecto hoy)
        appointments = await fetchAppointments(loggedInBarber, getCurrentDateISO());
      }
      
      // Filtrar por nombre y estado (ya sea que se cargaron todas o solo por fecha)
      let filtered = appointments.filter(a => {
          const matchesName = searchName ? a.nombre.toLowerCase().includes(searchName) : true;
          const matchesStatus = (filterStatus === 'all') ? true : 
                                (filterStatus === 'completed') ? a.completed : 
                                (!a.completed);
          return matchesName && matchesStatus;
      });

      renderAppointments(filtered);
    }

    function renderAppointments(appointments){
      appointmentListEl.innerHTML = '';
      if(appointments.length === 0){
        appointmentStatusEl.textContent = 'No se encontraron citas con los filtros aplicados.';
        return;
      }
      
      appointmentStatusEl.textContent = `Mostrando ${appointments.length} citas.`;

      appointments.forEach(a => {
        const item = document.createElement('div');
        item.className = `appointment-item ${a.completed ? 'completed' : ''}`;
        
        // Bloque de informaci√≥n
        const infoBlock = document.createElement('div');
        infoBlock.className = 'info-block';
        infoBlock.innerHTML = `
          <div>üìÖ **Fecha:** ${a.date} | ‚è∞ **Hora:** ${minutesToShortAmPm(a.startMinutes)}</div>
          <div>üë§ **Cliente:** <strong>${a.nombre}</strong></div>
          <div>üìû **Tel√©fono:** ${a.telefono}</div>
          <div>üíá‚Äç‚ôÇÔ∏è **Servicio:** ${a.servicio}</div>
          <div>‚è± **Duraci√≥n:** ${a.durationMinutes} min</div>
        `;

        // Bloque de acciones
        const actionsBlock = document.createElement('div');
        actionsBlock.className = 'actions';
        
        // Bot√≥n Finalizar/Pendiente
        const toggleBtn = document.createElement('button');
        toggleBtn.textContent = a.completed ? 'Marcar Pendiente' : 'Finalizar Cita';
        toggleBtn.onclick = () => toggleCompletion(a);
        actionsBlock.appendChild(toggleBtn);

        // Bot√≥n Editar
        const editBtn = document.createElement('button');
        editBtn.textContent = 'Editar';
        editBtn.onclick = () => openEditModal(a);
        actionsBlock.appendChild(editBtn);

        // Bot√≥n Eliminar
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Eliminar';
        deleteBtn.style.background = 'var(--danger)';
        deleteBtn.onclick = () => deleteAppointment(a);
        actionsBlock.appendChild(deleteBtn);

        item.appendChild(infoBlock);
        item.appendChild(actionsBlock);
        appointmentListEl.appendChild(item);
      });
    }

    // Tachar como ya finalizada
    async function toggleCompletion(appointment){
      if(!confirm(`¬øDeseas ${appointment.completed ? 'marcar como PENDIENTE' : 'FINALIZAR'} la cita de ${appointment.nombre} el ${appointment.date} a las ${minutesToShortAmPm(appointment.startMinutes)}?`)) return;
      
      const path = `appointments/${loggedInBarber}/${appointment.date}/${appointment._id}`;
      try{
        await update(ref(db, path), { completed: !appointment.completed });
        alert(`Cita ${appointment.completed ? 'marcada como pendiente' : 'finalizada'} con √©xito.`);
        loadAppointments(); // Recargar la lista
      } catch(e){
        alert('Error al actualizar el estado de la cita.');
        console.error(e);
      }
    }

    // Eliminar cita
    async function deleteAppointment(appointment){
      if(!confirm(`‚ö†Ô∏è ¬øEst√°s seguro de ELIMINAR la cita de ${appointment.nombre} el ${appointment.date} a las ${minutesToShortAmPm(appointment.startMinutes)}? Esta acci√≥n es irreversible.`)) return;
      
      const path = `appointments/${loggedInBarber}/${appointment.date}/${appointment._id}`;
      try{
        await remove(ref(db, path));
        alert('Cita eliminada con √©xito.');
        loadAppointments(); // Recargar la lista
      } catch(e){
        alert('Error al eliminar la cita.');
        console.error(e);
      }
    }


    // 4. L√ìGICA DEL MODAL DE EDICI√ìN
    const editModal = document.getElementById('edit-modal');
    const btnCloseEdit = document.getElementById('btnCloseEdit');
    const btnSaveEdit = document.getElementById('btnSaveEdit');
    const editNombre = document.getElementById('edit-nombre');
    const editTelefono = document.getElementById('edit-telefono');
    const editServicio = document.getElementById('edit-servicio');
    const editFecha = document.getElementById('edit-fecha');
    const editHora = document.getElementById('edit-hora');
    const editOriginalDate = document.getElementById('edit-original-date');
    const editAppointmentKey = document.getElementById('edit-appointment-key');
    const editBarbero = document.getElementById('edit-barbero');

    function openEditModal(appointment){
      const [nombre, apellido] = appointment.nombre.split(' '); // Nombre completo
      
      editNombre.value = appointment.nombre; 
      editTelefono.value = appointment.telefono;
      editServicio.value = appointment.servicio;
      editFecha.value = appointment.date;
      editHora.value = minutesToTime(appointment.startMinutes);

      // Campos ocultos para la transacci√≥n
      editOriginalDate.value = appointment.date;
      editAppointmentKey.value = appointment._id;
      editBarbero.value = loggedInBarber;

      editModal.style.display = 'grid';
    }

    btnCloseEdit.addEventListener('click', () => { editModal.style.display = 'none'; });
    
    // Guardar Edici√≥n
    btnSaveEdit.addEventListener('click', async () => {
      const originalDate = editOriginalDate.value;
      const key = editAppointmentKey.value;
      const barbero = editBarbero.value;
      
      const newNombre = editNombre.value.trim();
      const newTelefono = editTelefono.value.trim();
      const newServicio = editServicio.value;
      const newDate = editFecha.value;
      const newTime = editHora.value;

      if(!newNombre || !newTelefono || !newServicio || !newDate || !newTime){
        alert('Completa todos los campos del formulario de edici√≥n.');
        return;
      }
      
      const newStartMinutes = timeToMinutes(newTime);
      const newDuration = getDuration(newServicio);
      const newEndMinutes = newStartMinutes + newDuration;
      
      if(newEndMinutes > CLOSE_MIN){ alert('La nueva cita terminar√≠a fuera del horario operativo.'); return; }

      // 1. ELIMINAR cita original si la fecha ha cambiado
      let deletePath = null;
      if(originalDate !== newDate){
          deletePath = `appointments/${barbero}/${originalDate}/${key}`;
      }
      
      // 2. BUSCAR CONFLICTOS en la nueva fecha (incluyendo la cita a editar si no se movi√≥)
      const newParentPath = `appointments/${barbero}/${newDate}`;
      const newParentRef = ref(db, newParentPath);

      try{
          await runTransaction(newParentRef, (current) => {
              if(current === null) current = {};
              const existing = Object.values(current || {}).map(x => ({ 
                  key: x._id || Number(x.startMinutes), // La clave es o _id o startMinutes
                  start: Number(x.startMinutes), 
                  end: Number(x.endMinutes || (Number(x.startMinutes) + Number(x.durationMinutes))) 
              }));
              existing.sort((a,b)=>a.start-b.start);
              
              for(const iv of existing){
                  // Si es la misma cita (misma key/startMinutes y misma fecha original), la ignoramos
                  if(originalDate === newDate && iv.key == key) continue; 
                  
                  // Verificar conflicto con otras citas
                  if(newStartMinutes < iv.end && newEndMinutes > iv.start) throw new Error('CONFLICT');
              }

              // Si llegamos aqu√≠, no hay conflicto. Crear/Actualizar la cita.
              current[key] = {
                  nombre: newNombre,
                  telefono: newTelefono,
                  barbero: barbero,
                  servicio: newServicio,
                  durationMinutes: newDuration,
                  startMinutes: newStartMinutes,
                  endMinutes: newEndMinutes,
                  date: newDate,
                  priceCOP: "Consultar con Barbero",
                  createdAt: Date.now(),
                  completed: false // Asumir pendiente al editar
              };
              return current;
          });
          
          // 3. Si la transacci√≥n fue exitosa y la fecha cambi√≥, eliminar la antigua
          if(deletePath){
              await remove(ref(db, deletePath));
          }

          editModal.style.display = 'none';
          alert('Cita actualizada correctamente.');
          loadAppointments();
      } catch(err){
          console.error('Transaction error:', err);
          if(String(err).includes('CONFLICT')) alert('La hora seleccionada entra en conflicto con otra cita o el barbero est√° ausente. Revisa.');
          else alert('Error guardando la cita.');
      }
    });

    
    // 5. L√ìGICA DE GESTI√ìN DE AUSENCIAS
    const absenceTypeSelect = document.getElementById('absence-type');
    const absenceDayControls = document.getElementById('absence-day-controls');
    const absenceIntervalControls = document.getElementById('absence-interval-controls');
    const absenceDateInput = document.getElementById('absence-date');
    const intervalDateInput = document.getElementById('interval-date');
    const intervalStartInput = document.getElementById('interval-start');
    const intervalEndInput = document.getElementById('interval-end');
    const absenceReasonInput = document.getElementById('absence-reason');
    const btnAddAbsence = document.getElementById('btnAddAbsence');
    const absenceListEl = document.getElementById('absence-list');
    const absenceListStatusEl = document.getElementById('absence-list-status');

    // Cambiar la vista de control
    absenceTypeSelect.addEventListener('change', (e) => {
      if(e.target.value === 'day'){
        absenceDayControls.style.display = 'block';
        absenceIntervalControls.style.display = 'none';
      } else {
        absenceDayControls.style.display = 'none';
        absenceIntervalControls.style.display = 'block';
      }
    });

    btnAddAbsence.addEventListener('click', async () => {
      if(!loggedInBarber) return;
      const type = absenceTypeSelect.value;
      const reason = absenceReasonInput.value.trim() || 'No disponible';
      
      let dateISO, dataToSave;

      if(type === 'day'){
        dateISO = absenceDateInput.value;
        if(!dateISO){ alert('Selecciona una fecha para la ausencia de d√≠a completo.'); return; }
        dataToSave = { isFullDay: true, reason: reason, intervals: [] };
      } else { // interval
        dateISO = intervalDateInput.value;
        const start = intervalStartInput.value;
        const end = intervalEndInput.value;
        if(!dateISO || !start || !end){ alert('Completa la fecha, hora de inicio y fin del intervalo.'); return; }
        
        const startMin = timeToMinutes(start);
        const endMin = timeToMinutes(end);

        if(endMin <= startMin){ alert('La hora de fin debe ser posterior a la hora de inicio.'); return; }
        if(startMin < OPEN_MIN || endMin > CLOSE_MIN){ alert('El intervalo debe estar dentro del horario operativo (7:00am - 10:00pm).'); return; }

        dataToSave = { 
            isFullDay: false, 
            reason: 'Ausencia temporal programada',
            intervals: [{ start: startMin, end: endMin, reason: reason }] 
        };
      }
      
      const path = `absences/${loggedInBarber}/${dateISO}`;
      
      try{
        await runTransaction(ref(db, path), (current) => {
          // *** CORRECCI√ìN 1: Se inicializa 'reason' con string vac√≠o si el nodo es nuevo ***
          if(current === null) current = { isFullDay: false, intervals: [], reason: '' }; 

          if(type === 'day'){
            // Ausencia de d√≠a completo siempre reemplaza
            return dataToSave;
          } else {
            // Ausencia por intervalo
            if(current.isFullDay){ throw new Error('DAY_BLOCKED'); } // No se puede agregar intervalo si ya est√° bloqueado el d√≠a
            
            const newInterval = dataToSave.intervals[0];
            let intervals = current.intervals || [];

            // Verificar conflicto con ausencias existentes
            for(const existing of intervals){
                if(newInterval.start < existing.end && newInterval.end > existing.start){
                    throw new Error('INTERVAL_CONFLICT');
                }
            }

            intervals.push(newInterval);
            intervals.sort((a,b) => a.start - b.start);

            // *** CORRECCI√ìN 2: Se usa un valor por defecto si 'current.reason' es null/undefined ***
            return { 
                isFullDay: false, 
                intervals: intervals, 
                reason: current.reason || 'Bloqueo de horario parcial' 
            };
          }
        });
        
        alert(`Ausencia guardada correctamente para el ${dateISO}.`);
        loadAbsences();
      } catch(e){
        if(String(e).includes('DAY_BLOCKED')){
            alert('Error: Ya existe un bloqueo de d√≠a completo para esta fecha.');
        } else if (String(e).includes('INTERVAL_CONFLICT')){
             alert('Error: El nuevo intervalo de ausencia se solapa con uno ya existente.');
        } else {
            alert('Error al guardar la ausencia.');
            console.error(e);
        }
      }
    });
    
    // Cargar y mostrar ausencias existentes
    async function loadAbsences(){
        if(!loggedInBarber) return;
        absenceListEl.innerHTML = '';
        absenceListStatusEl.textContent = 'Cargando ausencias...';

        try{
            const path = `absences/${loggedInBarber}`;
            const snap = await get(child(ref(db), path));
            let absences = [];

            if(snap.exists()){
                const dates = snap.val();
                for(const date of Object.keys(dates)){
                    const data = dates[date];
                    if(data.isFullDay){
                        absences.push({ date: date, type: 'D√≠a Completo', reason: data.reason, path: `absences/${loggedInBarber}/${date}` });
                    }
                    if(data.intervals && data.intervals.length > 0){
                        data.intervals.forEach((interval, index) => {
                            absences.push({ 
                                date: date, 
                                type: 'Intervalo', 
                                reason: interval.reason,
                                interval: `${minutesToTime(interval.start)} - ${minutesToTime(interval.end)}`,
                                path: `absences/${loggedInBarber}/${date}/intervals/${index}`
                            });
                        });
                    }
                }
            }
            
            absences.sort((a,b) => a.date.localeCompare(b.date));
            absenceListStatusEl.textContent = `Tienes ${absences.length} bloqueos de agenda.`;
            
            absences.forEach(abs => {
                const item = document.createElement('div');
                item.className = 'appointment-item absence';
                
                const infoBlock = document.createElement('div');
                infoBlock.className = 'info-block';
                infoBlock.innerHTML = `
                  <div>üìÖ **Fecha:** ${abs.date}</div>
                  <div>üö´ **Tipo:** <strong>${abs.type}</strong> ${abs.interval ? `(${abs.interval})` : ''}</div>
                  <div>üí¨ **Motivo:** ${abs.reason}</div>
                `;

                const actionsBlock = document.createElement('div');
                actionsBlock.className = 'actions';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Desbloquear';
                deleteBtn.style.background = 'var(--danger)';
                deleteBtn.onclick = () => deleteAbsence(abs);
                actionsBlock.appendChild(deleteBtn);

                item.appendChild(infoBlock);
                item.appendChild(actionsBlock);
                absenceListEl.appendChild(item);
            });
            
        } catch(e){
            console.error("Error fetching absences:", e);
            absenceListStatusEl.textContent = 'Error al cargar las ausencias.';
        }
    }
    
    // Eliminar ausencia
    async function deleteAbsence(absence){
        if(!confirm(`‚ö†Ô∏è ¬øEst√°s seguro de eliminar el bloqueo de agenda del ${absence.date} (${absence.type})?`)) return;

        try{
            if(absence.type === 'D√≠a Completo'){
                // Eliminar el nodo completo de la fecha
                await remove(ref(db, absence.path));
            } else {
                // Para eliminar un intervalo, necesitamos el array completo de la fecha
                const datePath = `absences/${loggedInBarber}/${absence.date}`;
                const dateRef = ref(db, datePath);
                
                await runTransaction(dateRef, (current) => {
                    if(current === null) return current; // No existe

                    let intervals = current.intervals || [];
                    const [targetDate, , indexStr] = absence.path.split('/').slice(-3);
                    const index = Number(indexStr);

                    if(index >= 0 && index < intervals.length){
                        intervals.splice(index, 1); // Eliminar el elemento
                    }
                    
                    if(intervals.length === 0 && !current.isFullDay){
                         return null; // Si no quedan intervalos, eliminamos el nodo de la fecha
                    }
                    
                    current.intervals
